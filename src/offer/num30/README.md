# 最小的K个数

**题目**

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。

**测试地址**
[最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

## 解题思路

第一种，用快速排序的`partition`的方法。时间复杂度是o(N)
通过一个`partition`之后，会得到一个下标index,只需要判断index是不是等于k - 1即可。
如果index > k - 1,则说明要对index之前的部分进行`partition`
如果index < k - 1,则说明要对index之后的部分进行`partition`
最后输出前k个数即可。

第二种，用堆排序，建立一个大顶推。时间复杂度是o(N* logK)。空间复杂度是o(K)
我们这里记录大小为N的数组为A数组，大小为K的数组为B数组。

1. 建立一个k大小的B数组，先将A中前k个数放入B数组中。
2. 对B数组建立一个大顶堆。
3. 从下标为k的地方(i = k)，开始向后遍历，判断A[i]与B[0]的大小，如果小于，则设置B[0] = A[i],然后重新调整大顶堆。

因为是大顶堆，所以堆顶是最大值，如果新放入的值比最大值小，则说明最大值不应该在大顶堆中，让堆顶等于新加入的值，然后调整堆。

对于K大小的堆，任何调整的复杂度都是logK，所以最终复杂度是o(N * logK)

第一种虽然快，但是如果N很大无法用数组保存，比如数十G大小，则不适用。
第二种虽然慢一些，但如果N很大，K很小，比如k = 100，则完全适用。


